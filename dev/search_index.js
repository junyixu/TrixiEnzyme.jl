var documenterSearchIndex = {"docs":
[{"location":"api.html#The-TrixiEnzyme-Module","page":"API reference","title":"The TrixiEnzyme Module","text":"","category":"section"},{"location":"api.html","page":"API reference","title":"API reference","text":"TrixiEnzyme","category":"page"},{"location":"api.html#TrixiEnzyme","page":"API reference","title":"TrixiEnzyme","text":"TrixiEnzyme\n\nTrixiEnzyme.jl is a component package of the Trixi.jl ecosystem and integrates Trixi.jl with Compiler-Based (LLVM level) automatic differentiation via Enzyme.jl for hyperbolic partial differential equations (PDEs). The integration of Trixi.jl with Compiler-Based (LLVM level) automatic differentiation via Enzyme.jl offers the following benefits: facilitates rapid forward mode AD, enables reverse mode AD, supports cross-language AD, and critically, supports mutating operations and caching, on which Trixi.jl relies, to enhance the performance of both simulation runs and AD. The final deliverable will include as many of Trixi's advanced features as possible, such as adaptive mesh refinement, shock capturing, etc., showcasing the benefits of differentiable programming in Julia's ecosystem.\n\n\n\n\n\n","category":"module"},{"location":"api.html#Module-Index","page":"API reference","title":"Module Index","text":"","category":"section"},{"location":"api.html","page":"API reference","title":"API reference","text":"Modules = [TrixiEnzyme]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api.html#Detailed-API","page":"API reference","title":"Detailed API","text":"","category":"section"},{"location":"api.html","page":"API reference","title":"API reference","text":"Modules = [TrixiEnzyme]\nOrder   = [:constant, :type, :function, :macro]","category":"page"},{"location":"api.html#TrixiEnzyme.jacobian_enzyme_forward","page":"API reference","title":"TrixiEnzyme.jacobian_enzyme_forward","text":"jacobian_enzyme_forward(semi::SemidiscretizationHyperbolic)\n\nUses the right-hand side operator of the semidiscretization semi and forward mode automatic differentiation to compute the Jacobian J of the semidiscretization semi at state u0_ode.\n\n\n\njacobian_enzyme_forward(f!::F, x::AbstractArray; N = pick_batchsize(x)) where F <: Function\n\nUses the function f! and forward mode automatic differentiation to compute the Jacobian J\n\nExamples\n\njulia> x = -1:0.5:1;\njulia> batch_size = 2;\njulia> jacobian_enzyme_forward(TrixiEnzyme.upwind!, x, N=batch_size)\n5×5 Matrix{Float64}:\n -0.2  -0.0  -0.0  -0.0   0.2\n  0.2  -0.2  -0.0  -0.0  -0.0\n -0.0   0.2  -0.2  -0.0  -0.0\n -0.0  -0.0   0.2  -0.2  -0.0\n -0.0  -0.0  -0.0   0.2  -0.2\n\n\n\n\n\n","category":"function"},{"location":"api.html#TrixiEnzyme.pick_batchsize","page":"API reference","title":"TrixiEnzyme.pick_batchsize","text":"pick_batchsize(x)\npick_batchsize(semi)\n\nReturn a reasonable batch size for batched differentiation.\n\nArguments\n\nx: AbstractArray\nsemi: SemidiscretizationHyperbolic in Trixi.jl\n\nNotes\n\nInspired by https://github.com/EnzymeAD/Enzyme.jl/pull/1545/files\n\nwarning: Warning\nThis function is experimental, and not part of the public API.\n\nExamples\n\njulia> pick_batchsize(rand(3))\n3\n\njulia> pick_batchsize(rand(20))\n11\n\n\n\n\n\n","category":"function"},{"location":"api.html#TrixiEnzyme.upwind!-Tuple{Vector, Vector, Any}","page":"API reference","title":"TrixiEnzyme.upwind!","text":"upwind!(du, u, cache)\n\nvanilla upwind scheme\n\n\n\n\n\n","category":"method"},{"location":"Acknowledgments.html#Acknowledgments","page":"Acknowledgments","title":"Acknowledgments","text":"","category":"section"},{"location":"Acknowledgments.html","page":"Acknowledgments","title":"Acknowledgments","text":"The entire project, along with this blog website, is developed and maintained by Junyi(@junyixu). The whole project is under the guidance of two outstanding professors, Michael(@sloede) and Hendrik(@ranocha), from Trixi Framework community.","category":"page"},{"location":"Acknowledgments.html","page":"Acknowledgments","title":"Acknowledgments","text":"The project also received support from other Julia contributors, including Benedict from Trixi Framework community.","category":"page"},{"location":"examples.html#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples.html#scalar-linear-advection-equation-in-1D","page":"Examples","title":"scalar linear advection equation in 1D","text":"","category":"section"},{"location":"examples.html","page":"Examples","title":"Examples","text":"We will implement the scalar linear advection equation in 1D with the advection velocity 1 and compute its Jacobian.","category":"page"},{"location":"examples.html","page":"Examples","title":"Examples","text":"using Trixi\nusing TrixiEnzyme\n\n# %%\n# equation with a advection_velocity of `1`.\nadvection_velocity = 1.0\nequations = LinearScalarAdvectionEquation1D(advection_velocity)\n\n# create DG solver with flux lax friedrichs and LGL basis\nsolver = DGSEM(polydeg=3, surface_flux=flux_lax_friedrichs)\n\n# distretize domain with `TreeMesh`\ncoordinates_min = -1.0 # minimum coordinate\ncoordinates_max = 1.0 # maximum coordinate\nmesh = TreeMesh(coordinates_min, coordinates_max,\n                initial_refinement_level=4, # number of elements = 2^4\n                n_cells_max=30_000)\n\n# create initial condition and semidiscretization\ninitial_condition_sine_wave(x, t, equations) = SVector(1.0 + 0.5 * sin(pi * sum(x - equations.advection_velocity * t)))\n\nsemi = SemidiscretizationHyperbolic(mesh, equations, initial_condition_sine_wave, solver)\n\nJ1 = jacobian_ad_forward(semi)\nJ2 = jacobian_enzyme_forward(semi;N=1)\n\nJ1 == J2","category":"page"},{"location":"index.html#TrixiEnzyme","page":"Home","title":"TrixiEnzyme","text":"","category":"section"},{"location":"index.html#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"Wikipedia's automatic differentiation entry is a useful resource for learning about the advantages of AD techniques over other common differentiation methods (such as finite differencing).","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"TrixiEnzyme is not a registered Julia package, and it can be installed by running:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"] add https://github.com/junyixu/TrixiEnzyme.jl.git","category":"page"},{"location":"index.html#Configuring-Batch-Size","page":"Home","title":"Configuring Batch Size","text":"","category":"section"},{"location":"index.html","page":"Home","title":"Home","text":"TrixiEnzyme.jl performs partial derivative evaluation on one \"batch\" of the input vector at a time. Each differentiation of a batch requires a call to the target function as well as additional memory proportional to the square of the batch's size. Thus, a smaller batch size makes better use of memory bandwidth at the cost of more calls to the target function, while a larger batch size reduces calls to the target function at the cost of more memory bandwidth.","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> x = -1:0.5:1;\njulia> batch_size = 2\njulia> @time jacobian_enzyme_forward(TrixiEnzyme.upwind!, x, N=batch_size)\n  0.000040 seconds (31 allocations: 1.547 KiB)\n5×5 Matrix{Float64}:\n -0.2  -0.0  -0.0  -0.0   0.2\n  0.2  -0.2  -0.0  -0.0  -0.0\n -0.0   0.2  -0.2  -0.0  -0.0\n -0.0  -0.0   0.2  -0.2  -0.0\n -0.0  -0.0  -0.0   0.2  -0.2\n\njulia> x = -1:0.01:1;\njulia> @time jacobian_enzyme_forward(TrixiEnzyme.upwind!, x, N=2);\n  0.000539 seconds (1.34 k allocations: 390.969 KiB)\njulia> @time jacobian_enzyme_forward(TrixiEnzyme.upwind!, x, N=11);\n  0.000332 seconds (307 allocations: 410.453 KiB)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"If you do not explicitly provide a chunk size, TrixiEnzyme will try to guess one for you based on your input vector:","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"julia> x = -1:0.01:1;\njulia> @time jacobian_enzyme_forward(TrixiEnzyme.upwind!, x);\n  0.000327 seconds (307 allocations: 410.453 KiB)","category":"page"},{"location":"index.html","page":"Home","title":"Home","text":"Benchmark for a 401x401 Jacobian of TrixiEnzyme.upwind! (Lower is better): (Image: upwind) Enyme(@batch) means applying Polyester.@batch to middlebatches.","category":"page"},{"location":"Contact.html#Contact-Developer","page":"Contact Developer","title":"Contact Developer","text":"","category":"section"},{"location":"Contact.html","page":"Contact Developer","title":"Contact Developer","text":"If you have questions, suggestions, or are interested in contributing, feel free to reach out our developer, Junyi, via junyixu0@gmail.com.","category":"page"}]
}
